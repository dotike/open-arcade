#!/usr/bin/env python3
# -*- mode: python -*-
# -*- coding: utf-8 -*-

'''
grv-destroy -- Destroy a grv, hierarchically based on grv name or VPC id.

Use the help flag, 'grv destroy -h' for more info.

# TODO: class based destroy handling, (dev, staging, production)
# TODO: multi-admin "lockout" for high class GRVS (production, staging)
'''

# @depends: boto3, python (>=3.7)
__version__ = '0.1'
__author__ = 'Addepar Infrastructure Platform Tools Team <iptools@addepar.com>'
__description__ = "Hierarchically destroy a GRV."

import os
import sys
import getopt
import boto3
from arclib import common
from arclib import grv as grv
from arclib import cli as cli
from arclib.cli import vprint
import time
from botocore.config import Config


try:
    grv_conf = grv.source(str(os.environ['MYHIER'] + '/etc/grv.conf'))
    grv_tld = grv_conf['grv_tld']
    info_domain = 'info.{}'.format(grv_tld)
    _me = os.path.basename(sys.argv[0])
    _cmd = _me.split('-', 1)[1:][0]
except Exception as err:
    raise type(err)('{0}: {1}'.format(sys.argv[0], err))


# ---------------------------------------------------------
#
# usage
#
# ---------------------------------------------------------
def usage(msg=None, _exit=1, _fdout=None):
    '''
    Usage with exit handling properties.

    Args:
        msg: string, optional user message to print
        _exit: int as exit code
        _fdout: can be sys.stderr or sys.stdout (or other fd)

    Returns:
        help message text block
        will exit program
    '''
    _desc = """
{myname}

  Utility for deleting a GRV and all it's components.
  Version {version}.

  Used regularly, this utility will:
    - ask or confirm creation options up front
      (using aws live data)
    - delete a grv, in reverse hierarchical order
      (this stage has many stages, which may fail, and can be resumed using manifest/assets)

  This utility requires that a given AWS account has been initialized for use,
  please see 'grv init' for further information on AWS account initialization.
  This utility also operates on one configured AWS account at a time, see
  'README.md' to set up access to your account.

usage:

  {myname}
  {myname} [-v|3] [-A] <arcade_name.tld>
  {myname} [-h]

arguments:

  -A <arcade_name.tld>
     The ARCADE name we wish to destroy.  This name cannot
     be arbitrary, but must correspnd to a live grv name.
     Can be in the format 'arcade_name' or 'arcade_name.tld'.

  -3 S3 buckets to be deleted along with arcace.
     (requires user conformation)

  -v  Verbose, prints human-centric output to stderr.

  -h  Print this help to stdout, and exit zero.


see also:
   grv create -h
"""
    if _fdout is None:
        if _exit == 0:
            _fdout = sys.stdout
        else:
            _fdout = sys.stderr

    print(_desc.format(myname=os.path.basename(sys.argv[0]),
                       version=__version__,), file=_fdout)
    _fdout.flush()
    if msg is not None and msg != '':
        print('\n' + str(msg), file=_fdout)
        _fdout.flush()
    sys.exit(_exit)


# ---------------------------------------------------------
#
# _loadconfig
#
# ---------------------------------------------------------
def _loadconfig():
    '''
    Loads config needs from files and API calls.

    Args: none.
    Requires grv configDict object 'pconf', which we add to.

    Returns: nothing.
    If verbose flag is thrown to program, variables are printed
    after they are set.
    '''
    vprint("processing _loadconfig()")

    for key, val in grv.source(str(os.environ['MYHIER'] + '/etc/grv.conf')).items():
        vprint("{0}='{1}'".format(key, pconf.alt_set(key, val)))

    vprint("{0}='{1}'".format('info_domain', pconf.alt_set(
        'info_domain', 'info.{}'.format(pconf['grv_tld']))))

    vprint("{0}='{1}'".format('grv_classes', pconf.alt_set(
        'grv_classes', pconf['grv_class_types'].strip().split(' '))))

    pconf['consoleurl'] = "https://{0}.signin.aws.amazon.com/console".format(
        grv.fetch_account_id()[0])
    vprint("consoleurl='{}'".format(pconf['consoleurl']))

    pconf['user'] = grv.aws_whoami()
    vprint("user='{}'".format(pconf['user']))
    pconf['batch_comment'] = '{0} {1} {2}'.format(
        _me, pconf['user'], grv.wallclock())
    vprint("batch_comment='{}'".format(pconf['batch_comment']))

    #
    # End of _loadconfig
    #
    

# ---------------------------------------------------------
#
# _validgrv
#
# ---------------------------------------------------------
def _validgrv():
    '''
    Validates need from grv name, handles preamble user input.

    Args: none.
    Requires grv configDict object 'pconf', which we add to.

    Returns: nothing.
    If verbose flag is thrown to program, additional messages may
    be printed after they are set.

    '''
    try:
        if not pconf['yestoall']:
            grv.redirect('stdout')
            if not pconf['grv_name']:
                print("Which GRV do you wish to destroy?")
                sys.stdout.write(
                    "Type the GRV name, or type '?' for a list of GRVS available: ")
                pconf['grv_choice'] = input()
                vprint("grv_choice='{}'".format(pconf['grv_choice']))
                if pconf['grv_choice'] == '?':
                    print("Querying all global regions for valid GRVs...")
                    print("")
                    pconf['live_grvs'] = grv.list_grvs()
                    print("  name\t\tclass\tregion")
                    for grv_id in list(pconf['live_grvs'].keys()):
                        grv_id_tags = grv.aws_tags_dict(
                            pconf['live_grvs'][grv_id]['Tags'])
                        # TODO: figure out how to print output like `column -t -s ' '`
                        print("  {0}\t\t{1}\t{2}".format(
                            grv_id_tags['Name'],
                            grv_id_tags['grv_class'],
                            pconf['live_grvs'][grv_id]['region']))
                    print("")
                    print("More information for these regions grvs:")
                    print(pconf['consoleurl'])
                    print("")
                    print("Which GRV do you wish to destroy?")
                    sys.stdout.write("Type the GRV name: ")
                    pconf['grv_choice'] = input()
                    vprint("grv_choice='{}'".format(pconf['grv_choice']))

                if not pconf['grv_choice']:
                    grv.die(
                        "You must supply a grv id in the form of 'grv_id' or 'grv_id.tld'.")
                else:
                    pconf['grv_name'] = pconf['grv_choice']

        if pconf['grv_name']:
            vprint("loading live metadadata for VPC")
            if not pconf['live_grvs']:
                try:  # if the vpc has already been deleted, we have nothing,
                    pconf['live_grvs'] = grv.list_grvs(pconf['grv_name'])
                except Exception:
                    pconf['live_grvs'] = {}
            for grv_id in list(pconf['live_grvs'].keys()):
                grv_id_tags = grv.aws_tags_dict(
                    pconf['live_grvs'][grv_id]['Tags'])
                if grv_id_tags['Name'] == pconf['grv_name']:
                    pconf['target_vpc_metadict'] = pconf['live_grvs'][grv_id]
                    pconf['target_vpc_tags'] = grv_id_tags

            if '.' in pconf['grv_name']:
                _shortname = pconf['grv_name'].split('.', 1)[0]
            else:
                _shortname = pconf['grv_name']
            pconf['state_name'] = 'used.{0}.grvname.{1}'.format(
                _shortname, pconf['info_domain'])
            vprint("state_name='{}'".format(pconf['state_name']))

        if not pconf['yestoall']:
            if not pconf['target_vpc_metadict']:
                print("More information grvs in your account:")
                print(pconf['consoleurl'])
                grv.die("The grv name '{}' does not appear to match any live GRVS.".format(
                    pconf['grv_name']))
            else:
                print("")
                print("WARNING: destroy operations are permanent.")
                print("You are about to destroy all GRV objects for '{0}', under VPC '{1}'.".format(
                    pconf['grv_name'], pconf['target_vpc_metadict']['VpcId']))
                sys.stdout.write("Are you sure you wish to proceed?: [y/n] ")
                if not cli.yes_no(pconf.yestoall):
                    sys.exit(0)
            grv.redirect()
    except Exception as err:
        raise type(err)('_validgrv(): {}'.format(err))
    #
    # End of _validgrv
    #

# ---------------------------------------------------------
#
# _destroy
#
# ---------------------------------------------------------
def _destroy():
    '''
    Assuming all necessary vars are set, (pconf), we check for each type of
    object, and destroy it.  If missing, we move on.  If failure or error, we
    raise error and stop.

    Args: none, (assumes pconf configDict)

    Returns: none, but prints conformations to stdout.
    '''
    try:
        try:
            region = pconf['target_vpc_metadict']['region']
        except Exception:
            region = pconf['aws_default_region']
        grv.set_region(region)

##############################################################################
        # TODO: unclear what we want to do with GRVs still in create state,
        # but this is the place to handle or communicate this.
        # check for 'unlock' build state in route53 before proceeding,
        # throw error to interactive that they may clobber someone's build
        #
        # grv.prettyPrint(grv.r53_lookup(name=pconf['state_name'], dns_type='TXT'))


##############################################################################
        # fetch our vpc id, used throughout
        try:
            vpc_exists = grv.validate_grv_id(pconf['grv_name'])
            vprint("VPC named {0} exists as VPC id: {1}".format(
                pconf['grv_name'], vpc_exists))
        except Exception:
            vpc_exists = ''
            vprint("VPC named {} does not exist.".format(pconf['grv_name']))

##############################################################################
# workspot: ec2 sgrv reservation remmoval check
# not yet tested with sgrv instances and reservations

##############################################################################
# workspot: security groups remmoval check

# PASS: security groups (which must be attached to a VPC) appear to be deleted
# properly when the VPC itself is deleted.

##############################################################################
# Route Tables - pass.  VPC deletion is confirmed to delete it's route tables.

##############################################################################
# RDS/S3 endpoint remmoval check (not actual RDS/S3 removal)

# WE WILL NOT DESTROY S3 BUCKETS USING THIS TOOLING FOR NOW

        print("REMOVING SERVICE ENDPOINTS FOR GRV: {0}".format(
            pconf['grv_name']))
        service_endpoints = grv.list_vpc_endpoints(
            grv_id=pconf['grv_name'], region=region)
        if service_endpoints:
            grv.prettyPrint(service_endpoints)
        vpc_endpoint_list = list(service_endpoints.keys())
        if vpc_endpoint_list:
            try:
                kill_endp_cliennt = boto3.client('ec2', region_name=region)
                kill_endp_response = kill_endp_cliennt.delete_vpc_endpoints(
                    DryRun=False,
                    VpcEndpointIds=vpc_endpoint_list,
                )
                print(
                    "BEWARE: response may lie to you, e.g. 'Unsuccessful' vs 'Successful' is rarely correct:")
                grv.prettyPrint(kill_endp_response)
            except Exception as err:
                raise ValueError(err)

##############################################################################
        # remove all instances belonging to this GRV
        print("REMOVING ALL INSTANCES BELONGING TO GRV: {0}".format(
            pconf['grv_name']))
        grv_instances = grv.list_grv_instances(pconf['grv_name'])
        if grv_instances:
            grv.prettyPrint(grv_instances)

        if grv_instances:
            instance_kill_list = []
            for ins_id, ins_meta in grv_instances.items():
                try:
                    ins_named = ins_meta['TagSane']['Name']
                except Exception:
                    ins_named = "NoName"
                print("STACKING INSTANCE FOR TERMINATION: {0} {1}".format(
                    ins_id, ins_named))
                grv.upsert_list(instance_kill_list, ins_id)
            print("ABOUT TO TERMINATE {} GRV_INSTANCES CONTAINED IN THIS GRV".format(
                len(instance_kill_list)))
            try:
                killclient = boto3.client('ec2', region_name=region)
                killresponse = killclient.terminate_instances(
                    InstanceIds=instance_kill_list,
                    DryRun=False
                )
                grv.prettyPrint(killresponse)
            except Exception as err:
                raise ValueError(err)

            # crude, provide time for termination requests to take effect
            # looping variations have edge cases we can't see until way down
            # the chain, like IGW bindings clearing for hosts with public
            # IP addresses, etc...
            time.sleep(10)

##############################################################################
        # remove bootstrap ssh key named for this GRV,
        key_name = "bootstrap.{}".format(pconf['grv_name'])
        key_exists_meta = grv.list_key_pairs(grv_id=pconf['grv_name'])
        for onekey_name, onekey_dict in key_exists_meta.items():
            if onekey_name == key_name:
                print((
                    "KEY EXISTS AS '{1}', DELETING KEY WITH FINGERPRINT '{0}'".format(
                        onekey_dict['KeyFingerprint'], onekey_name)))
                try:
                    keyclient = boto3.client('ec2', region_name=region)
                    keyresponse = keyclient.delete_key_pair(
                        KeyName=key_name,
                        DryRun=False,
                    )
                    grv.prettyPrint(keyresponse)
                except Exception as err:
                    raise ValueError(err)

##############################################################################
        # acl subnet assignments to default acl,

        if vpc_exists:
            vprint("check acl associations with subnets, move subnets to default acl")
            existing_acls = grv.list_network_acls(
                grv_id=pconf['grv_name'], region=region)
            grv.prettyPrint(existing_acls)

            default_acl_meta = {}
            all_associations = []
            for acl_id, acl_meta in existing_acls.items():
                if acl_meta['VpcId'] == vpc_exists:
                    if acl_meta['IsDefault']:
                        default_acl_meta = acl_meta
                for association in acl_meta['Associations']:
                    grv.upsert_list(all_associations, association)
            grv.prettyPrint(default_acl_meta)
            grv.prettyPrint(all_associations)

            for association in all_associations:
                try:
                    replaceclient = boto3.client('ec2', region_name=region)
                    replaceresponse = replaceclient.replace_network_acl_association(
                        AssociationId=association['NetworkAclAssociationId'],
                        DryRun=False,
                        NetworkAclId=default_acl_meta['NetworkAclId'],
                    )
                    grv.prettyPrint(replaceresponse)
                except Exception as err:
                    raise ValueError(err)

##############################################################################
        # acl destroy, from hierarchical relation to vpc

        if vpc_exists:
            vprint("check acls for deletion")
            existing_acls = grv.list_network_acls(
                grv_id=pconf['grv_name'], region=region)
            grv.prettyPrint(existing_acls)
            for acl_id, acl_meta in existing_acls.items():
                try:   # belt and suspenders
                    if acl_meta['IsDefault']:
                        vprint(
                            "Bypassing Default ACL, vpc deletion stage will reap: '{}'".format(acl_id))
                    elif acl_meta['VpcId'] == vpc_exists:
                        vprint("Deleting acl: '{}'".format(acl_id))
                        aclclient = boto3.client('ec2', region_name=region)
                        aclresponse = aclclient.delete_network_acl(
                            DryRun=False,
                            NetworkAclId=acl_id,
                        )
                        grv.prettyPrint(aclresponse)
                except Exception as err:
                    raise ValueError(err)

##############################################################################
# note: route table gets automatically reaped with VPC deletion.
##############################################################################

        doThis = False
        if doThis:
            # igw destroy, requisite for VPC destroy.
            vprint("check igw deletion")
            igw_attached = {}
            all_igws = grv.list_igw(region=region)
            for igw_name, igw_meta in all_igws.items():
                for attached in igw_meta['Attachments']:
                    if attached['VpcId'] == vpc_exists:
                        igw_attached[igw_name] = igw_meta
            all_igws = {}

            igwclient = boto3.client('ec2', region_name=region)
            for attached_key, attached_dict in igw_attached.items():
                try:
                    vprint("Detaching '{}' from '{}'.".format(
                        attached_key, vpc_exists))
                    igwresponse = igwclient.detach_internet_gateway(
                        DryRun=False,
                        InternetGatewayId=attached_key,
                        VpcId=vpc_exists,
                        )
                    grv.prettyPrint(igwresponse)
                    print("sleeping 6 seconds for igw detach to settle...")
                    time.sleep(6)  # just sleep.  Too difficult to reap, catch
                    # orphaned igw in cleanup utils later.
                    vprint("Delete attempt: '{}'".format(attached_key))
                    deligwresponse = igwclient.delete_internet_gateway(
                        DryRun=False,
                        InternetGatewayId=attached_key,
                        )
                    grv.prettyPrint(deligwresponse)
                except Exception as err:
                    raise ValueError(err)

##############################################################################
        # subnets destroy, from hierarchical relation to vpc

        # we have to check for valid vpc existence for a given GRV, because
        # of an AWS API bug whereby VPC subnets may be returned as
        # "'State': 'available'" after their parent VPC is deleted. Mindblown.
        # see vpc_exists above

        def _delete_subnet(subnet_id):
            try:
                print("deleting subnet: {}".format(subnet_id))
                subnet_client = boto3.client('ec2', region_name=region)
                # subnet_client = boto3.client('ec2')
                response = subnet_client.delete_subnet(
                    SubnetId=subnet_id,
                    DryRun=False,
                )
                grv.prettyPrint(response)
            except Exception as err:
                raise ValueError(err)

        if vpc_exists:
            # list subnets associated with our GRV, if any,
            # grv.prettyPrint(grv.list_grv_subnets(grv_id=pconf['grv_name'], sregion=region))
            try:
                live_subs = grv.list_grv_subnets(
                    grv_id=pconf['grv_name'], sregion=region)
            except Exception:
                live_subs = {}
                vprint("There appear to be no subnets belonging to named VPC.")
            print(live_subs)
            for subkey, subdict in live_subs.items():
                if subdict['State'] == 'available':
                    vprint("'{0}' in state '{1}' for deletion.".format(
                        subkey, subdict['State']))
                    if subdict['VpcId'] == pconf['target_vpc_metadict']['VpcId']:
                        vprint("{0} belongs to VPC {1}, deleting it now".format(
                            subkey, subdict['VpcId']))
                        # delete each one, checking metadata for VPC id before
                        # each deletion.
                        # josef - _delete_subnet is broken
                        #_delete_subnet(subkey)
            print(
                "Sleeping 20 seconds, to provide time for AWS networking to coalesce before VPC deletion...")
            time.sleep(20)
        print("SUBNETS DELETE: passed.")

##############################################################################
#
# Josef added code here
#
##############################################################################
        # delete s3 buckets
        if pconf['delete_s3']:
            print("")
            print("DANGER S3 delete option passed, deleting S3 buckets.\n")
            print("")
            print("WARNING: destroy operations are permanent.")
            print("You are about to destroy all S3 buckets associated with for '{0}', under VPC '{1}'.".format(
                pconf['grv_name'], pconf['target_vpc_metadict']['VpcId']))
            if not pconf['yestoall']:
                sys.stdout.write("Are you sure you wish to proceed?: [y/n] ")
                if not cli.yes_no():
                    sys.exit(0)
            deleteS3Buckets(pconf)
        else:
            print("Leaving behind S3 buckets for manual operator cleanup.  See -h for other options.\n")

        # delete instances
        deleteEc2Instances(pconf)

        # delete auto scale group
        deleteAutoScaleGroup(pconf)
        
        # delete eks nodegroup
        deleteEksNodegroup(pconf)

        # delete eks
        deleteEks(pconf)
        
        # delete load balance
        deleteLoadBalance(pconf)
##############################################################################
        # vpc destroy
        # This is broken
        doThis = False

        if doThis:
            try:
                vpc_exists = grv.validate_grv_id(pconf['grv_name'])
                print("VPC named {0} exists as VPC id: {1}".format(
                    pconf['grv_name'], vpc_exists))
            except Exception:
                vpc_exists = ''
                print("VPC named {} does not exist.".format(pconf['grv_name']))

            print("vpc exists as: '{}'".format(vpc_exists))

            try:
                if vpc_exists:
                    try:
                        vpcclient = boto3.client('ec2', region_name=region)
                        # The problem is here
                        vpcresponse = vpcclient.delete_vpc(
                            VpcId=vpc_exists,
                            DryRun=False
                            )
                        grv.prettyPrint(vpcresponse)
                    except Exception as err:
                        raise ValueError(err)
            # Drop a looper in here... (also one for IGW destroy?)
            # workspot, bughunt, this commonly fails apparently based on
            # routes/network/other objects not being freed/cleared on the
            # AWS side.  Works fine from the console...
            except Exception as err_vpc:
                print("")
                print("")
                print("Error deleting vpc '{}', you may need to delete it manually from the console:".format(vpc_exists))
                print(pconf['consoleurl'])
                raise ValueError("VPC delete stage error: ".format(err_vpc))

            print("VPC DESTROY: passed.")

##############################################################################
        # dns names destroy
        # This is not in the same order as creating a GRV, because we need
        # the names and zone in order to perform various lookups to delete
        # things like the vpc itself.
        try:
            # dns_type='', show_zone=False)
            zone_namedict = grv.list_dns_names(zone=pconf['grv_name'])
        except Exception:
            zone_namedict = {}
        if zone_namedict:
            pconf['zone_id'] = zone_namedict['zone_id']
            for one_name in zone_namedict['names']:
                # leave SOA and NS alone, deleting these can have *odd*
                # AWS consequences:
                if one_name['Type'] != 'SOA' and one_name['Type'] != 'NS':
                    # don't batch delete change_resource_record_sets()
                    # because we will run
                    # into pagination complication.  This sucks, but we
                    # gotta just delete
                    # each name with an individual API call or we
                    # overcomplicate things
                    # to the point of being un-debuggable inane.
                    print(one_name['Name'], one_name['Type'])
                    nameconn = boto3.client('route53')
                    nameresponse = nameconn.change_resource_record_sets(
                        HostedZoneId=pconf['zone_id'],
                        ChangeBatch={
                            'Comment': pconf['batch_comment'],
                            'Changes': [
                                {
                                    'Action': 'DELETE',
                                    'ResourceRecordSet': {
                                        'Name': one_name['Name'],
                                        'Type': one_name['Type'],
                                        'TTL': one_name['TTL'],
                                        'ResourceRecords':
                                        one_name['ResourceRecords'],
                                        },
                                    },
                                ],
                            },
                        )
                    grv.prettyPrint(nameresponse)
        print("ZONE RECORDS DELETE: passed.")

##############################################################################
        # dns zone destroy
        try:
            # remember, we may already have pconf['zone_id'] from zones list above
            pconf['private_zone_id'] = grv.tld_to_zone_id(pconf['grv_name'])
            if pconf['private_zone_id']:
                vprint("private zone '{0}' exists as id '{1}'.".format(
                    pconf['grv_name'], pconf['private_zone_id']))
        except Exception:
            vprint("No rotute53 private zone in rout53 for GRV: '{}'".format(
                _target_name))

        if pconf['private_zone_id']:
            print("deleting private zone '{0}', id '{1}'.".format(
                pconf['grv_name'], pconf['private_zone_id']))
            zoneclient = boto3.client('route53')
            zoneresponse = zoneclient.delete_hosted_zone(
                Id=pconf['private_zone_id']
            )
            grv.prettyPrint(zoneresponse)

        print("ZONE DELETE: passed.")

##############################################################################
        # route53 'used' names in info domain
        #   - grv name
        #   - grv netblock
        # (releases name and netblock back to pool for use)

        try:
            grvname_used_lookup = grv.r53_lookup(
                name=pconf['state_name'], dns_type='TXT')
        except Exception:
            grvname_used_lookup = []

        if grvname_used_lookup:
            singular_create_uid = []
            for value in grvname_used_lookup:
                if len(value) == 36:  # we have matched our UID
                    grv.upsert_list(singular_create_uid, value)
            if len(singular_create_uid) > 1:
                msg = "Name has more than two values which appear to be UID create strings.  " + \
                      "You may need to finish this off by finding the create UID string for the " + \
                      "domain '{0}', and manually delete both the 'grvname' and 'grvnet' info names " + \
                      "using the aws console <{1}>: {2}".format(
                          pconf['state_name'],
                          pconf['consoleurl'],
                          singular_create_uid
                      )
                raise ValueError(msg)
            else:
                pconf['create_uid'] = singular_create_uid[0]

            # now we get real dirty, because route53 names have no tags,
            all_grvnet_names = grv.list_dns_names(
                name='*grvnet.{}'.format(pconf['info_domain']))
            pconf['zone_id'] = all_grvnet_names['zone_id']
            for namedict in all_grvnet_names['names']:
                # strip down to only used names,
                if namedict['Name'].startswith('used.'):
                    for rrecord in namedict['ResourceRecords']:
                        if rrecord['Value'] == '"{}"'.format(pconf['create_uid']):
                            pconf['used_net_name'] = namedict['Name']
                            vprint("found grvnet name match: '{}'".format(
                                pconf['used_net_name']))
                            # validate the name
                            grvnet_used_lookup = grv.r53_lookup(
                                name=pconf['used_net_name'], dns_type='TXT')

        # only delete if we can confidently delete them both,
        if pconf['used_net_name'] and pconf['state_name']:
            vprint("'{0}' '{1}'".format(
                pconf['state_name'], pconf['used_net_name']))

            used_name_list = []
            # don't botch this order, net first:
            grv.upsert_list(used_name_list,
                            grv.list_dns_names(name=pconf['used_net_name'], zone=pconf['info_domain'], dns_type='TXT')['names'][0])
            grv.upsert_list(used_name_list,
                            grv.list_dns_names(name=pconf['state_name'], zone=pconf['info_domain'], dns_type='TXT')['names'][0])

            for used_name in used_name_list:
                try:
                    nameconn = boto3.client('route53')
                    nameresponse = nameconn.change_resource_record_sets(
                        HostedZoneId=pconf['zone_id'],
                        ChangeBatch={
                            'Comment': pconf['batch_comment'],
                            'Changes': [
                                {
                                    'Action': 'DELETE',
                                    'ResourceRecordSet': {
                                        'Name': used_name['Name'],
                                        'Type': used_name['Type'],
                                        'TTL': used_name['TTL'],
                                        'ResourceRecords': used_name['ResourceRecords'],
                                    },
                                },
                            ],
                        },
                    )
                    grv.prettyPrint(nameresponse)
                except Exception as err:
                    raise ValueError(err)
        else:
            print("WARNING: cannot complete final step:")
            print("(info names may already be deleted)")
            msg = "We are unable to remove the 'used...{0}' domains which are used to reserve grv name and neblock.  You may need to find and delete them off by finding the create UID string for the domain '{1}', and manually delete both the 'grvname' and 'grvnet' info names using the aws console <{2}>.".format(
                pconf['info_domain'],
                pconf['state_name'],
                pconf['consoleurl']
            )
            print(msg)

        print("INFO RECORDS DELETE: passed.")

        grv.set_region()
    except Exception as err:
        raise type(err)('_destroy(): {}'.format(err))
    #
    # End of _destroy
    #

# ---------------------------------------------------------
#
# delete S3 buckets
#
# ---------------------------------------------------------
def deleteS3Buckets(D):
    if D['verbose']:
        print("Deleting S3 buckets")
        
    s3List = []
    client = boto3.client('s3')
    args = D['args']

    s3Name = D['grv_name'].replace('.arc', '')
    s3Name = s3Name.replace('_', '')
    D['s3_name_str'] = s3Name

    response = client.list_buckets()
    if response['ResponseMetadata']['HTTPStatusCode'] == 200:
        Buckets = response['Buckets']
        for entry in Buckets:
            if s3Name in entry['Name']:
                s3List.append(entry['Name'])

        for bucket in s3List:
            response = client.list_objects_v2(Bucket=bucket)
            if 'Contents' in response:
                Contents = response['Contents']
                for entry2 in Contents:
                    s3Object = entry2['Key']

                    response2 = client.delete_object(Bucket=bucket,
                                                     Key=s3Object)
        for bucket in s3List:
            response = client.delete_bucket(Bucket=bucket)

    return

# ---------------------------------------------------------
#
# delete instances
#
# ---------------------------------------------------------
def deleteEc2Instances(D):

    if D['verbose']:
        print("Deleting EC2 Instances")

    args = D['args']
    indexCount = 0
    instanceList = []
    region = D['aws_default_region']
    
    ec2 = boto3.resource('ec2')
    toolConfig = Config(region_name = region)
    client = boto3.client('ec2', config=toolConfig)

    #aws ec2 describe-instances --filters Name=tag:grv_name,Values=$ARCADE_NAME
    filters = [{'Name': 'tag:grv_name', 'Values': [D['grv_name']] }]
    response = client.describe_instances(Filters = filters)

    Reservations = response['Reservations']
    if len(Reservations) > 0:
        for entry in Reservations:
            instanceId = entry['Instances'][0]['InstanceId']
            instanceList.append(instanceId)

            resp = ec2.instances.filter(InstanceIds = instanceList).terminate()
    
    return
    #

# ---------------------------------------------------------
#
# delete auto scale group
#
# ---------------------------------------------------------
def deleteAutoScaleGroup(D):

    if D['verbose']:
        print("Deleting Auto Scale Groups")
        
    args = D['args']
    indexCount = 0
    arcadeName = D['grv_name'].replace('.', '-')
    asgList = []

    region = D['aws_default_region']
    client = boto3.client('autoscaling',region_name=region)

    response = client.describe_auto_scaling_groups()
    HTTPStatusCode = response['ResponseMetadata']['HTTPStatusCode']

    if HTTPStatusCode == 200:
        asGroups = response['AutoScalingGroups']
        for entry1 in asGroups:
            AutoScalingGroupName = entry1['AutoScalingGroupName']
            Tags = entry1['Tags']
            for entry2 in Tags:
                if arcadeName in entry2['Value']:
                    asgList.append(AutoScalingGroupName)

    if len(asgList) > 0:
        for entry in asgList:
            response = client.delete_auto_scaling_group(
                AutoScalingGroupName = entry,
                ForceDelete = True)
            

    return
    #
        
# ---------------------------------------------------------
#
# delete eks nodegroup
#
# ---------------------------------------------------------
def deleteEksNodegroup(D):

    if D['verbose']:
        print("Deleting EKS Nodegroups")
        
    args = D['args']
    indexCount = 0
    arcadeName = D['grv_name'].replace('.', '-')
    ngList = []
    clusterName = ""
    clusterFound = False

    client = boto3.client('eks')
    response = client.list_clusters()
    Clusters = response['clusters']
    for entry in Clusters:
        if arcadeName in entry:
            clusterName = entry
            clusterFound = True

    if clusterFound:
        response = client.list_nodegroups(clusterName = clusterName)
        if len(response['nodegroups']) > 0:
            nodeGroup = response['nodegroups'][0]

        response = client.delete_nodegroup(
            clusterName = clusterName,
            nodegroupName = nodeGroup)

    return
    #

# ---------------------------------------------------------
#
# delete eks
#
# ---------------------------------------------------------
def deleteEks(D):

    if D['verbose']:
        print("Deleting EKS")
        
    args = D['args']
    indexCount = 0
    arcadeName = D['grv_name'].replace('.', '-')
    eksList = []
    eksFound = False
    
    client = boto3.client('eks')

    response = client.list_clusters()
    Clusters = response['clusters']
    for entry in Clusters:
        if arcadeName in entry:
            eksName = entry
            eksFound = True

    if eksFound:
        response = client.describe_cluster(name = eksName)
        clusterName = response['cluster']['name']
        
        response = client.delete_cluster(name = clusterName)

    return
    #
        
# ---------------------------------------------------------
#
# delete load balance
#
# ---------------------------------------------------------
def deleteLoadBalance(D):

    if D['verbose']:
        print("Deleting Load Balancers")
        
    vpcId = D['vpc_id']
    args = D['args']
    indexCount = 0
    lbList = []
    
    client = boto3.client('elbv2')

    lbs = client.describe_load_balancers(PageSize=400)
    for lb in lbs["LoadBalancers"]:
        if lb['VpcId'] == vpcId:
            lbArn = lb['LoadBalancerArn']
            lbList.append(lbArn)

    if len(lbList) > 0:
        for lb in lbList:
            response = client.delete_load_balancer(
                LoadBalancerArn = lb)

    return
    #

# ---------------------------------------------------------
#
# main
#
# ---------------------------------------------------------
def main(argv):
    '''
    Handles command line input.

    Args: argv

    Returns: That depends.  -h for usage/help.
    '''
    try:
        try:
            opts, args = getopt.getopt(argv, 'A:3vhy', ["help"])
            for flag, opt in opts:
                if flag == '-v':
                    global verbose
                    os.environ['VERBOSE'] = 'True'
                    vprint("processing argv: {}".format(argv))
                elif flag == '-h' or flag == '--help':
                    usage('', 0)
                    sys.exit(0)
                elif flag == '-y':
                    pconf['yestoall'] = True
                    vprint("yestoall='{}'".format(pconf['yestoall']))
                elif flag == '-A':
                    pconf['grv_name'] = opt
                    vprint("grv_name='{}'".format(pconf['grv_name']))
                elif flag == '-3':
                    pconf['delete_s3'] = True
                    vprint("delete_s3='{}'".format(pconf['delete_s3']))

            # Validate that aws credentials are valid
            common.validate_aws_creds()

            if not pconf['grv_name']:
                grv.die("ARCADE name args required e.g. '-A <arcade_name.tld>', '{} -h' for all options.".format(
                    _me))

            _loadconfig()
            _validgrv()
            _destroy()

            account_id_data = grv.fetch_account_id()
            print("DESTROY OPERATION FINISHING FOR '{}'.".format(pconf['grv_name']))
            print("\nDestroy of GRV components are not complete, console cleanup is required.")
            print("console: https://{0}.signin.aws.amazon.com/console\n".format(account_id_data[0]))

            print("Check the AWS console to ensure all GRV components have been destroyed:")
            print("  - VPC, subnets, subcomponents")
            print("  - S3 Buckets")
            print("  - Route53 private zone\n")

        except (getopt.GetoptError, RuntimeError, TypeError, NameError) as err:
            raise ValueError(err)

    except Exception as err:
        raise type(err)('{0} main(): {1}'.format(sys.argv[0], err))

    # Exit nonzero until we get another pass at fixing the details
    sys.exit(93)

    #
    # End of main
    #



#
# Initialize variables which do not have external data dependencies,
# e.g. don't make api calls or load config files.
#
try:
    pconf = grv.configDict()
    _me = os.path.basename(sys.argv[0])
    _cmd = _me.split('-', 1)[1:][0]
except Exception as err:
    raise type(err)('{0}: {1}'.format(sys.argv[0], err))

# ---------------------------------------------------------
#
# main entry point
#
# ---------------------------------------------------------
if __name__ == '__main__':
    main(sys.argv[1:])
